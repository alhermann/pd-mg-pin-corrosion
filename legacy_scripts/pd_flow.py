# -*- coding: utf-8 -*-
"""PD-Flow.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jmWOaxfpjpw0Lalrg3UzddUhTAkwD1lu
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap

# =============== 1) PARAMS ===============
dx     = 8.0e-6
delta  = 3.0 * dx
m      = int(round(delta / dx))

R_w = 40e-6
R_t = 0.15e-3
L_w = 0.40e-3
L_u = 0.08e-3
L_d = 0.08e-3

rho_f   = 1000.0
rho_m   = 1800.0
mu_f    = 1.0e-3
gamma   = 1.4
c0      = 10.0
alpha_p  = 2.0
alpha_mu = 16.0/3.0

c_fluid_init  = 0.0
c_metal_init  = 1.0
D_f           = 5.0e-9
D_m           = 5.0e-7
c_crit        = 0.2

dt      = 2.0e-7
nsteps  = 10000
DO_PLOTS   = True
PLOT_EVERY = 10

# target flow via body force
Q_paper = 1.0e-6 / 60.0
A_gap   = np.pi * (R_t**2 - R_w**2)
U_in    = Q_paper / A_gap
ramp_steps = 50
f_z_ramp = U_in / (ramp_steps * dt)

# =============== 2) GRID ===============
x = np.arange(-R_t, R_t + dx/2, dx)
z = np.arange(-L_u, L_w + L_d + dx/2, dx)
Nx, Nz = len(x), len(z)
X, Z   = np.meshgrid(x, z, indexing="ij")

in_tube  = (np.abs(X) <= R_t)
is_metal = in_tube & (np.abs(X) <= R_w) & (Z >= 0.0) & (Z <= L_w)

collar = np.zeros((Nx, Nz), dtype=bool)
for kk in range(m):
    collar[:, kk] = in_tube[:, kk] & (~is_metal[:, kk])

rho = np.where(is_metal, rho_m, rho_f).astype(float)
v   = np.zeros((Nx, Nz, 2), dtype=float)
phi = np.zeros((Nx, Nz), dtype=np.int8); phi[is_metal] = 1
c   = np.full((Nx, Nz), c_fluid_init, dtype=float); c[is_metal] = c_metal_init

print(f"Grid {Nx} x {Nz}, total={Nx*Nz}")
print(f"Fluid nodes={(in_tube & (~is_metal)).sum()}, metal nodes={is_metal.sum()}, collar nodes={collar.sum()}")
print(f"U_in target={U_in:.3e} m/s, m={m}, dx={dx:.3e}, delta={delta:.3e}")

# =============== 3) STENCIL ===============
def beta(r_ij, delta, dx):
    if r_ij <= delta - dx/2:
        return 1.0
    elif r_ij <= delta + dx/2:
        return (delta + dx/2 - r_ij) / dx
    else:
        return 0.0

stencil = []
for di in range(-m, m+1):
    for dk in range(-m, m+1):
        if di == 0 and dk == 0:
            continue
        rx = di * dx
        rz = dk * dx
        dist = np.hypot(rx, rz)
        if dist > delta + dx/2:
            continue
        w = beta(dist, delta, dx)
        if w <= 0.0:
            continue
        A_ij = w * dx * dx
        e_vec = np.array([rx, rz]) / dist
        stencil.append((di, dk, dist, A_ij, e_vec))

# =============== 4) PLOT ===============
def plot_fields(step, phi, c, v, rho, x, z, is_metal, in_tube):
    vz = v[:, :, 1]
    vm = np.linalg.norm(v, axis=2)
    # peridynamic eos pressure
    p = (rho_f * c0**2 / gamma) * ((rho / rho_f)**gamma - 1.0)

    fig, axs = plt.subplots(1, 5, figsize=(18, 4))

    # 1) phase
    axs[0].imshow(phi.T, origin="lower",
                  extent=[x.min(), x.max(), z.min(), z.max()],
                  cmap=ListedColormap(["#ffffff", "#ffcc00"]),
                  vmin=0, vmax=1, aspect="equal")
    axs[0].set_title(f"phase {step}")

    # 2) concentration
    im1 = axs[1].imshow(c.T, origin="lower",
                        extent=[x.min(), x.max(), z.min(), z.max()],
                        aspect="equal", vmin=0.0, vmax=1.0)
    axs[1].set_title("c")
    plt.colorbar(im1, ax=axs[1])

    mask = (~in_tube) | (is_metal)

    # 3) v_z
    vz_plot = np.ma.masked_where(mask, vz)
    im2 = axs[2].imshow(vz_plot.T, origin="lower",
                        extent=[x.min(), x.max(), z.min(), z.max()],
                        aspect="equal")
    axs[2].set_title("v_z (fluid)")
    plt.colorbar(im2, ax=axs[2])

    # 4) |v|
    vm_plot = np.ma.masked_where(mask, vm)
    im3 = axs[3].imshow(vm_plot.T, origin="lower",
                        extent=[x.min(), x.max(), z.min(), z.max()],
                        aspect="equal")
    axs[3].set_title("|v| (fluid)")
    plt.colorbar(im3, ax=axs[3])

    # 5) pressure (fluid)
    p_plot = np.ma.masked_where(mask, p)
    im4 = axs[4].imshow(p_plot.T, origin="lower",
                        extent=[x.min(), x.max(), z.min(), z.max()],
                        aspect="equal")
    axs[4].set_title("p (fluid)")
    plt.colorbar(im4, ax=axs[4])

    plt.tight_layout()
    plt.pause(0.01)
    plt.close(fig)

# =============== 5) TIME LOOP ===============
for step in range(nsteps):
    rho_new = rho.copy()
    v_new   = v.copy()
    c_new   = c.copy()
    phi_new = phi.copy()

    if step < ramp_steps:
        f_z = f_z_ramp
    else:
        f_z = 0.0

    # ----- PD-NS -----
    for i in range(Nx):
        for k in range(Nz):
            if not in_tube[i, k] or is_metal[i, k]:
                continue

            v_i   = v[i, k]
            rho_i = rho[i, k]
            p_i   = (rho_f * c0**2 / gamma) * ((rho_i / rho_f)**gamma - 1.0)

            sum_rho  = 0.0
            sum_conv = np.zeros(2)
            sum_pres = np.zeros(2)
            sum_visc = np.zeros(2)
            A_i      = 0.0

            for di, dk, dist, A_ij, e_vec in stencil:
                ii = i + di
                kk = k + dk

                # periodic in x
                if ii < 0: ii += Nx
                elif ii >= Nx: ii -= Nx
                # periodic in z
                if kk < 0: kk += Nz
                elif kk >= Nz: kk -= Nz

                if not in_tube[ii, kk]:
                    continue

                if is_metal[ii, kk]:
                    v_j   = np.array([0.0, 0.0])
                    rho_j = rho_f
                    p_j   = p_i
                else:
                    v_j   = v[ii, kk]
                    rho_j = rho[ii, kk]
                    p_j   = (rho_f * c0**2 / gamma) * ((rho_j / rho_f)**gamma - 1.0)

                sum_rho  += ((rho_j * v_j - rho_i * v_i) @ e_vec) / dist * A_ij
                sum_conv += (rho_j * (v_j @ e_vec) * v_j
                             - rho_i * (v_i @ e_vec) * v_i) / dist * A_ij
                sum_pres += ((p_j - p_i) / dist) * e_vec * A_ij
                ex, ez = e_vec
                P = np.array([[1.0 - ex*ex,   -ex*ez],
                              [  -ez*ex, 1.0 - ez*ez]])
                dv = v_j - v_i
                sum_visc += (P @ dv) / (dist**2) * A_ij
                A_i += A_ij

            if A_i > 0.0:
                rho_tmp = rho_i - (alpha_p * dt) / (np.pi * delta**2) * sum_rho
                v_tmp   = v_i + dt / rho_i * (
                    - (alpha_p / A_i) * sum_conv
                    - (alpha_p / A_i) * sum_pres
                    + (mu_f * alpha_mu / A_i) * sum_visc
                )
                # global body force (upwards)
                v_tmp[1] += dt * f_z
                rho_new[i, k] = rho_tmp
                v_new[i, k]   = v_tmp

    # metal reset
    v_new[is_metal]   = 0.0
    rho_new[is_metal] = rho_f

    # ----- TRANSPORT (unchanged) -----
    for i in range(Nx):
        for k in range(Nz):
            if not in_tube[i, k]:
                continue
            c_i   = c[i, k]
            phi_i = phi[i, k]
            v_i   = v_new[i, k] if phi_i == 0 else np.zeros(2)

            diff_sum = 0.0
            adv_sum  = 0.0
            for di, dk, dist, A_ij, e_vec in stencil:
                ii = i + di
                kk = k + dk
                if ii < 0: ii += Nx
                elif ii >= Nx: ii -= Nx
                if kk < 0: kk += Nz
                elif kk >= Nz: kk -= Nz
                if not in_tube[ii, kk] or is_metal[ii, kk]:
                    continue

                c_j   = c[ii, kk]
                phi_j = phi[ii, kk]
                v_j   = v_new[ii, kk] if phi_j == 0 else np.zeros(2)

                D_i = D_m if phi_i == 1 else D_f
                D_j = D_m if phi_j == 1 else D_f
                D_ij = 0.5 * (D_i + D_j)
                d_ij = 4.0 * D_ij / (np.pi * delta**2)
                diff_sum += d_ij * (c_j - c_i) / (dist**2) * A_ij

                if (phi_i == 0) or (phi_j == 0):
                    v_i_b = (2.0 / (np.pi * delta**2)) * (v_i @ e_vec)
                    v_j_b = (2.0 / (np.pi * delta**2)) * (v_j @ e_vec)
                    v_bar = 0.5 * (v_i_b + v_j_b)
                    if v_bar > 0.0:
                        adv_sum += v_bar * (c_i - c_j) * A_ij
                    elif v_bar < 0.0:
                        adv_sum += v_bar * (c_j - c_i) * A_ij

            c_new[i, k] = c_i + dt * diff_sum - dt * adv_sum

    newly_fluid = (phi == 1) & (c_new < c_crit)
    phi_new[newly_fluid] = 0
    rho_new[newly_fluid] = rho_f
    v_new[newly_fluid]   = 0.0

    rho, v, c, phi = rho_new, v_new, c_new, phi_new

    # ---- diags ----
    mask_fluid = in_tube & (~is_metal)
    vmax   = np.linalg.norm(v, axis=2)[mask_fluid].max()
    vzmean = v[mask_fluid, 1].mean()
    Q_2d   = (v[mask_fluid, 1] * dx).sum()
    vz_collar = v[collar, 1].mean() if collar.any() else 0.0

    print(f"[{step+1:04d}/{nsteps}] vmax={vmax:.3e} | vz_mean={vzmean:.3e} "
          f"| Q2d={Q_2d:.3e} | vz_coll={vz_collar:.3e} | f_z={f_z:.3e}")

    if DO_PLOTS and ((step % PLOT_EVERY) == 0 or step == nsteps-1):
        plot_fields(step, phi, c, v, rho, x, z, is_metal, in_tube)





import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap

# =============== 1) PARAMS ===============
dx     = 8.0e-6
delta  = 3.0 * dx
m      = int(round(delta / dx))

# geom
R_w = 40e-6
R_t = 0.15e-3
L_w = 0.40e-3
L_u = 0.08e-3
L_d = 0.08e-3

# fluid / PD-NS
rho_f   = 1000.0
rho_m   = 1800.0
mu_f    = 1.0e-3
gamma   = 1.4
c0      = 10.0
alpha_p  = 2.0
alpha_mu = 16.0/3.0

# transport
c_fluid_init  = 0.0
c_metal_init  = 1.0
D_f           = 5.0e-9
D_m           = 5.0e-7
c_crit        = 0.2

nsteps  = 10000
DO_PLOTS   = True
PLOT_EVERY = 10

# =============== 2) GRID ===============
x = np.arange(-R_t, R_t + dx/2, dx)
z = np.arange(-L_u, L_w + L_d + dx/2, dx)
Nx, Nz = len(x), len(z)
X, Z   = np.meshgrid(x, z, indexing="ij")

in_tube  = (np.abs(X) <= R_t)
is_metal = in_tube & (np.abs(X) <= R_w) & (Z >= 0.0) & (Z <= L_w)

# top Î´ fluid rows = OUTFLOW (open region in the physical domain)
outflow = np.zeros((Nx, Nz), dtype=bool)
for kk in range(Nz - m, Nz):
    outflow[:, kk] = in_tube[:, kk] & (~is_metal[:, kk])

rho = np.where(is_metal, rho_m, rho_f).astype(float)
v   = np.zeros((Nx, Nz, 2), dtype=float)
phi = np.zeros((Nx, Nz), dtype=np.int8); phi[is_metal] = 1
c   = np.full((Nx, Nz), c_fluid_init, dtype=float); c[is_metal] = c_metal_init

# Mg-4Ag inflow (we prescribe this on ghost bottom)
Q_paper = 1.0e-6 / 60.0
A_gap   = np.pi * (R_t**2 - R_w**2)
U_in    = Q_paper / A_gap
ramp_steps = 50

# CFL must come AFTER U_in is known
CFL_target = 0.4
v_ref = U_in
dt_conv = CFL_target * dx / max(v_ref, 1e-12)
D_max = max(D_f, D_m)
dt_diff = CFL_target * dx * dx / max(D_max, 1e-12)
dt_acoustic = CFL_target * dx / c0
dt = min(dt_conv, dt_diff, dt_acoustic)
print(f"dt set to {dt:.3e} s (conv={dt_conv:.3e}, diff={dt_diff:.3e}, ac={dt_acoustic:.3e})")

print(f"Grid {Nx} x {Nz}, total={Nx*Nz}")
print(f"Fluid nodes={(in_tube & (~is_metal)).sum()}, metal nodes={is_metal.sum()}, outflow nodes={outflow.sum()}")
print(f"U_in target={U_in:.3e} m/s, m={m}, dx={dx:.3e}, delta={delta:.3e}")

# =============== 3) STENCIL ===============
def beta(r_ij, delta, dx):
    if r_ij <= delta - dx/2:
        return 1.0
    elif r_ij <= delta + dx/2:
        return (delta + dx/2 - r_ij) / dx
    else:
        return 0.0

stencil = []
for di in range(-m, m+1):
    for dk in range(-m, m+1):
        if di == 0 and dk == 0:
            continue
        rx = di * dx
        rz = dk * dx
        dist = np.hypot(rx, rz)
        if dist > delta + dx/2:
            continue
        w = beta(dist, delta, dx)
        if w <= 0.0:
            continue
        A_ij = w * dx * dx
        e_vec = np.array([rx, rz]) / dist
        stencil.append((di, dk, dist, A_ij, e_vec))

# =============== 4) PLOT ===============
def plot_fields(step, phi, c, v, rho, x, z, is_metal, in_tube):
    vz = v[:, :, 1]
    vm = np.linalg.norm(v, axis=2)
    p  = (rho_f * c0**2 / gamma) * ((rho / rho_f)**gamma - 1.0)

    fig, axs = plt.subplots(1, 5, figsize=(18, 4))

    axs[0].imshow(phi.T, origin="lower",
                  extent=[x.min(), x.max(), z.min(), z.max()],
                  cmap=ListedColormap(["#ffffff", "#ffcc00"]),
                  vmin=0, vmax=1, aspect="equal")
    axs[0].set_title(f"phase {step}")

    im1 = axs[1].imshow(c.T, origin="lower",
                        extent=[x.min(), x.max(), z.min(), z.max()],
                        aspect="equal", vmin=0.0, vmax=1.0)
    axs[1].set_title("c"); plt.colorbar(im1, ax=axs[1])

    mask = (~in_tube) | (is_metal)

    vz_plot = np.ma.masked_where(mask, vz)
    im2 = axs[2].imshow(vz_plot.T, origin="lower",
                        extent=[x.min(), x.max(), z.min(), z.max()],
                        aspect="equal")
    axs[2].set_title("v_z (fluid)"); plt.colorbar(im2, ax=axs[2])

    vm_plot = np.ma.masked_where(mask, vm)
    im3 = axs[3].imshow(vm_plot.T, origin="lower",
                        extent=[x.min(), x.max(), z.min(), z.max()],
                        aspect="equal")
    axs[3].set_title("|v| (fluid)"); plt.colorbar(im3, ax=axs[3])

    p_plot = np.ma.masked_where(mask, p)
    im4 = axs[4].imshow(p_plot.T, origin="lower",
                        extent=[x.min(), x.max(), z.min(), z.max()],
                        aspect="equal")
    axs[4].set_title("p (fluid)"); plt.colorbar(im4, ax=axs[4])

    plt.tight_layout(); plt.pause(0.01); plt.close(fig)

# =============== 5) TIME LOOP ===============
for step in range(nsteps):
    rho_new = rho.copy()
    v_new   = v.copy()
    c_new   = c.copy()
    phi_new = phi.copy()

    # ramp inflow velocity
    vz_in = U_in * min(1.0, (step+1)/ramp_steps)

    # inlet ghost state
    p_in = 0.5 * rho_f * vz_in**2
    rho_in = rho_f * (1.0 + gamma * p_in / (rho_f * c0**2))**(1.0/gamma)
    c_in = c_fluid_init

    # outlet ghost state (pressure outlet, extrapolated velocity)
    p_out = 0.0
    rho_out = rho_f * (1.0 + gamma * p_out / (rho_f * c0**2))**(1.0/gamma)
    # c_out will be taken from last interior cell

    # ===== PD-NS (periodic x, physical z, ghost bottom+top) =====
    for i in range(Nx):
        for k in range(Nz):
            if not in_tube[i, k] or is_metal[i, k]:
                continue

            v_i   = v[i, k]
            rho_i = rho[i, k]
            p_i   = (rho_f * c0**2 / gamma) * ((rho_i / rho_f)**gamma - 1.0)

            sum_rho  = 0.0
            sum_conv = np.zeros(2)
            sum_pres = np.zeros(2)
            sum_visc = np.zeros(2)
            A_i      = 0.0

            for di, dk, dist, A_ij, e_vec in stencil:
                ii = i + di
                kk = k + dk

                # periodic in x
                if ii < 0: ii += Nx
                elif ii >= Nx: ii -= Nx

                # ---- z handling ----
                if kk < 0:
                    # bottom inlet ghost, kk in [-m, -1]
                    if kk >= -m and np.abs(x[ii]) <= R_t:
                        v_j   = np.array([0.0, vz_in])
                        rho_j = rho_in
                        p_j   = p_in
                        # no mass term from ghost:
                        sum_conv += (rho_j * (v_j @ e_vec) * v_j
                                     - rho_i * (v_i @ e_vec) * v_i) / dist * A_ij
                        sum_pres += ((p_j - p_i) / dist) * e_vec * A_ij
                        ex, ez = e_vec
                        P = np.array([[1.0 - ex*ex,   -ex*ez],
                                      [  -ez*ex, 1.0 - ez*ez]])
                        dv = v_j - v_i
                        sum_visc += (P @ dv) / (dist**2) * A_ij
                        A_i += A_ij
                    continue

                if kk >= Nz:
                    # TOP outlet ghost, kk in [Nz, Nz+m)
                    if kk < Nz + m and np.abs(x[ii]) <= R_t:
                        # extrapolate vertical velocity from last interior cell
                        v_top_int = v[i, Nz-1, 1]
                        v_j   = np.array([0.0, v_top_int])
                        rho_j = rho_out
                        p_j   = p_out
                        # no mass term from ghost:
                        sum_conv += (rho_j * (v_j @ e_vec) * v_j
                                     - rho_i * (v_i @ e_vec) * v_i) / dist * A_ij
                        sum_pres += ((p_j - p_i) / dist) * e_vec * A_ij
                        ex, ez = e_vec
                        P = np.array([[1.0 - ex*ex,   -ex*ez],
                                      [  -ez*ex, 1.0 - ez*ez]])
                        dv = v_j - v_i
                        sum_visc += (P @ dv) / (dist**2) * A_ij
                        A_i += A_ij
                    # if outside tube / higher: ignore
                    continue

                # inside domain
                if not in_tube[ii, kk]:
                    continue
                if is_metal[ii, kk]:
                    v_j   = np.array([0.0, 0.0])
                    rho_j = rho_f
                    p_j   = p_i
                else:
                    v_j   = v[ii, kk]
                    rho_j = rho[ii, kk]
                    p_j   = (rho_f * c0**2 / gamma) * ((rho_j / rho_f)**gamma - 1.0)

                # normal neighbor
                sum_rho  += ((rho_j * v_j - rho_i * v_i) @ e_vec) / dist * A_ij
                sum_conv += (rho_j * (v_j @ e_vec) * v_j
                             - rho_i * (v_i @ e_vec) * v_i) / dist * A_ij
                sum_pres += ((p_j - p_i) / dist) * e_vec * A_ij
                ex, ez = e_vec
                P = np.array([[1.0 - ex*ex,   -ex*ez],
                              [  -ez*ex, 1.0 - ez*ez]])
                dv = v_j - v_i
                sum_visc += (P @ dv) / (dist**2) * A_ij
                A_i += A_ij

            if A_i > 0.0:
                rho_tmp = rho_i - (alpha_p * dt) / (np.pi * delta**2) * sum_rho
                v_tmp   = v_i + dt / rho_i * (
                    - (alpha_p / A_i) * sum_conv
                    - (alpha_p / A_i) * sum_pres
                    + (mu_f * alpha_mu / A_i) * sum_visc
                )
                rho_new[i, k] = rho_tmp
                v_new[i, k]   = v_tmp

    # ===== METAL RESET =====
    v_new[is_metal]   = 0.0
    rho_new[is_metal] = rho_f

    # ===== TRANSPORT (with bottom+top ghosts) =====
    for i in range(Nx):
        for k in range(Nz):
            if not in_tube[i, k]:
                continue

            c_i   = c[i, k]
            phi_i = phi[i, k]
            v_i   = v_new[i, k] if phi_i == 0 else np.zeros(2)

            diff_sum = 0.0
            adv_sum  = 0.0
            for di, dk, dist, A_ij, e_vec in stencil:
                ii = i + di
                kk = k + dk

                # periodic x
                if ii < 0: ii += Nx
                elif ii >= Nx: ii -= Nx

                # z
                if kk < 0:
                    if kk >= -m and np.abs(x[ii]) <= R_t:
                        c_j = c_in
                        v_j = np.array([0.0, vz_in])
                    else:
                        continue
                elif kk >= Nz:
                    # top outlet ghost
                    if kk < Nz + m and np.abs(x[ii]) <= R_t:
                        # convective-like outflow
                        c_j = c[i, Nz-1]      # copy last interior scalar
                        v_j = np.array([0.0, v[i, Nz-1, 1]])
                    else:
                        continue
                else:
                    if not in_tube[ii, kk] or is_metal[ii, kk]:
                        continue
                    c_j = c[ii, kk]
                    v_j = v_new[ii, kk] if phi[ii, kk] == 0 else np.zeros(2)

                D_i = D_m if phi_i == 1 else D_f
                D_j = D_f  # ghosts are fluid
                D_ij = 0.5 * (D_i + D_j)
                d_ij = 4.0 * D_ij / (np.pi * delta**2)
                diff_sum += d_ij * (c_j - c_i) / (dist**2) * A_ij

                if (phi_i == 0):
                    v_i_b = (2.0 / (np.pi * delta**2)) * (v_i @ e_vec)
                    v_j_b = (2.0 / (np.pi * delta**2)) * (v_j @ e_vec)
                    v_bar = 0.5 * (v_i_b + v_j_b)
                    if v_bar > 0.0:
                        adv_sum += v_bar * (c_i - c_j) * A_ij
                    elif v_bar < 0.0:
                        adv_sum += v_bar * (c_j - c_i) * A_ij

            c_new[i, k] = c_i + dt * diff_sum - dt * adv_sum

    # corrosion
    newly_fluid = (phi == 1) & (c_new < c_crit)
    phi_new[newly_fluid] = 0
    rho_new[newly_fluid] = rho_f
    v_new[newly_fluid]   = 0.0

    # commit
    rho, v, c, phi = rho_new, v_new, c_new, phi_new

    # ===== DIAGNOSTICS =====
    mask_fluid = in_tube & (~is_metal)
    vmax   = np.linalg.norm(v, axis=2)[mask_fluid].max()
    vzmean = v[mask_fluid, 1].mean()
    Q_2d   = (v[mask_fluid, 1] * dx).sum()
    vz_outflow = v[outflow, 1].mean() if outflow.any() else 0.0

    print(f"[{step+1:04d}/{nsteps}] vmax={vmax:.3e} | vz_mean={vzmean:.3e} "
          f"| Q2d={Q_2d:.3e} | vz_out={vz_outflow:.3e} | vz_in(ghost)={vz_in:.3e}")

    if DO_PLOTS and ((step % PLOT_EVERY) == 0 or step == nsteps-1):
        plot_fields(step, phi, c, v, rho, x, z, is_metal, in_tube)









