# -*- coding: utf-8 -*-
"""PD_Micro_Macro_Corrosion_Lightweight.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f7ZbJLTudkQHpgHeUSUGq1mzpbB9g8HI
"""

"""
Lightweight Mg corrosion demo:
- Build a pool of micro RVEs (Voronoi grains, anisotropic lattice, grain boundaries).
- Homogenize each RVE to a scalar D_eff (µm²/s).
- Solve a simple peridynamic-style corrosion in 2D (80 µm disk) assigning D_eff tiles.
- Plot and save GIFs.

Requires: numpy, matplotlib, scipy (for Voronoi).
"""

import time
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation
from scipy.spatial import Voronoi

# -------------------------- small utilities -------------------------------- #

def disk_mask(nx, ny, dx_um, R_um, center=None):
    if center is None:
        cx, cy = (nx-1)/2, (ny-1)/2
    else:
        cx, cy = center
    yy, xx = np.meshgrid(np.arange(ny), np.arange(nx), indexing="ij")
    r2 = ((xx - cx) * dx_um)**2 + ((yy - cy) * dx_um)**2
    return (r2 <= R_um**2).T

def binary_dilate(mask, iters):
    if iters <= 0: return mask
    out = mask.copy()
    for _ in range(iters):
        nb = (np.roll(out,1,0)|np.roll(out,-1,0)|np.roll(out,1,1)|np.roll(out,-1,1))
        out = out | nb
    return out

def kappa_from_R(R):
    """Piecewise approx for inverting A(k)=I1/I0 ~ R (SciPy-free)."""
    R = float(np.clip(R, 1e-6, 1-1e-6))
    if R < 0.53:
        k = 2*R + R**3 + 5*R**5/6
    elif R < 0.85:
        k = -0.4 + 1.39*R + 0.43/(1-R)
    else:
        k = 1.0 / max(R**3 - 4*R**2 + 3*R, 1e-12)
    return float(k)

def estimate_n_sites(mean_eqdiam_um, L_um):
    # N ≈ (4/π)*(L/d)^2 — same formula as before, but clamped for simplicity
    n = int(round((4.0/np.pi) * (L_um / max(mean_eqdiam_um,1e-6))**2))
    return int(np.clip(n, 6, 1500))

# --------------------------- micro RVE builder ------------------------------ #

def voronoi_labels_from_sites(sites, nx, ny):
    """Assign each pixel its nearest site index (labels)."""
    x_cent = (np.arange(nx) + 0.5)/nx
    y_cent = (np.arange(ny) + 0.5)/ny
    Xc, Yc = np.meshgrid(x_cent, y_cent, indexing="ij")
    dist2 = (Xc[...,None]-sites[:,0])**2 + (Yc[...,None]-sites[:,1])**2
    return np.argmin(dist2, axis=-1)

def micro_rve_D_eff(
    nx=64, ny=64,
    L_um=24.0,
    mean_d_um=5.5,
    R_texture=0.90, mu_deg=0.0,
    D_perp_m2s=1e-12, D_par_m2s=1e-11,
    D_gb_m2s=1e-10,
    gb_thickness_nm=2.0,
    defect_frac=0.003, D_defect_m2s=1e-9,
    tol=1e-6, max_iter=10_000, seed=None,
    conductance_scaling=True,
    verbose=0
):
    """
    Build a Voronoi RVE, assemble D(x,y) in µm²/s, solve steady diffusion on [0,1]^2:
      ∇·(D∇C)=0, C(0,y)=1, C(1,y)=0, periodic in y. Return homogenized D_eff (µm²/s),
      plus micro fields and a stats dict including grain size & texture R.
    """
    rng = np.random.default_rng(seed)

    # --- sites & orientations ---
    n_sites = estimate_n_sites(mean_d_um, L_um)
    sites = rng.random((n_sites, 2))
    mu = np.deg2rad(mu_deg)
    kappa = kappa_from_R(R_texture)
    theta = rng.vonmises(mu=mu, kappa=kappa, size=n_sites)  # [rad]

    # grain interior diffusivity (in m^2/s; later convert)
    D_grain_m2s = D_perp_m2s + (D_par_m2s - D_perp_m2s) * (np.cos(theta - mu) ** 2)

    # --- Voronoi labels & base D map ---
    labels = voronoi_labels_from_sites(sites, nx, ny)
    Dm = D_grain_m2s[labels]  # m^2/s

    # --- Grain boundary band ---
    px_um = L_um / nx
    t_phys_um = gb_thickness_nm * 1e-3
    gb_px = max(1, int(round(t_phys_um / max(px_um, 1e-12))))
    edges = (labels != np.roll(labels, 1, 0)) | (labels != np.roll(labels, 1, 1))
    gb_mask = binary_dilate(edges, gb_px - 1)

    if conductance_scaling and t_phys_um > 0:
        w_eff_um = gb_px * px_um
        D_gb_eff = D_gb_m2s * max(w_eff_um / max(t_phys_um, 1e-12), 1.0)
    else:
        D_gb_eff = D_gb_m2s

    Dm[gb_mask] = D_gb_eff

    # --- random defects (sparse fast paths) ---
    if defect_frac > 0.0:
        mask = rng.random((nx, ny)) < defect_frac
        Dm[mask] = np.maximum(Dm[mask], D_defect_m2s)

    # convert to µm²/s for the solver
    D = (Dm * 1e12).astype(float)

    # --- steady diffusion solve (Jacobi/GS) ---
    C = np.zeros((nx, ny), float)
    C[0, :] = 1.0
    C[-1, :] = 0.0
    it = 0
    for it in range(1, max_iter + 1):
        C_old = C.copy()
        for i in range(1, nx - 1):
            for j in range(ny):
                j_up, j_dn = (j + 1) % ny, (j - 1) % ny
                aW = 2 * D[i, j] * D[i - 1, j] / (D[i, j] + D[i - 1, j])
                aE = 2 * D[i, j] * D[i + 1, j] / (D[i, j] + D[i + 1, j])
                aS = 2 * D[i, j] * D[i, j_dn] / (D[i, j] + D[i, j_dn])
                aN = 2 * D[i, j] * D[i, j_up] / (D[i, j] + D[i, j_up])
                C[i, j] = (aW * C[i - 1, j] + aE * C[i + 1, j] +
                           aS * C[i, j_dn] + aN * C[i, j_up]) / (aW + aE + aS + aN)
        if np.max(np.abs(C - C_old)) < tol:
            break

    # homogenized D_eff (µm²/s) from right boundary flux
    h = 1.0 / (nx - 1)
    grad = (C[-1, :] - C[-2, :]) / h
    flux = -D[-2, :] * grad
    D_eff = float(np.mean(flux))

    # --- micro stats (this fixes the NaNs) ---
    # grain areas -> equivalent diameters
    areas_pix = np.bincount(labels.ravel(), minlength=n_sites)  # pixels per grain
    areas_um2 = areas_pix * (px_um ** 2)
    d_eq_um = 2.0 * np.sqrt(areas_um2 / np.pi)
    d_eq_mean = float(np.mean(d_eq_um))
    d_eq_std = float(np.std(d_eq_um))

    # texture resultant length R and mean angle
    z = np.exp(1j * theta)
    R_meas = float(np.abs(np.mean(z)))
    mean_theta_deg = float(np.degrees(np.angle(np.mean(z))))

    stats = dict(
        nx=nx, ny=ny, L_um=L_um, px_um=px_um, gb_px=gb_px,
        n_sites=int(n_sites), iters=int(it),
        # NEW: grain size & texture
        grain_eqdiam_um_mean=d_eq_mean,
        grain_eqdiam_um_std=d_eq_std,
        orient_R=R_meas,
        orient_mean_deg=mean_theta_deg,
        # keep targets for reference
        R_texture_target=R_texture,
        mean_d_target_um=mean_d_um,
    )

    if verbose >= 2:
        print(f"[micro] iters={it:5d}  D_eff={D_eff:8.1f} µm²/s  "
              f"d̄={d_eq_mean:4.1f}±{d_eq_std:3.1f} µm  R={R_meas:4.2f} (target {R_texture:4.2f})  "
              f"gb_px={gb_px}  sites={n_sites}")

    return D_eff, C, D, sites, stats

def build_micro_pool(
    pool_n=12,
    L_um=24.0, px_target_um=0.75, mean_d_um=5.5, R_texture=0.90,
    mg_params=None, seed=0,
    verbose=1
):
    """
    Build 'pool_n' RVEs and return:
      - Deff_pool: (pool_n,) array of D_eff [µm²/s]
      - micro_pool: list of dicts per entry:
          { 'Deff', 'C', 'D', 'sites', 'stats', 'seed' }
      - info: dict of the shared micro settings

    verbosity:
      0 -> silent
      1 -> header + summary
      2 -> header + per-RVE one-liners + summary
    """

    if pool_n <= 0:
        raise ValueError("pool_n must be ≥ 1")

    if mg_params is None:
        mg_params = dict(
            D_perp_m2s=1e-12, D_par_m2s=1e-11,
            D_gb_m2s=1e-10, gb_thickness_nm=2.0,
            defect_frac=0.003, D_defect_m2s=1e-9,
            conductance_scaling=True
        )

    nx = ny = int(max(24, round(L_um / px_target_um)))
    px_um = L_um / nx

    if verbose >= 1:
        print(
            "[micro-pool] building "
            f"n={pool_n} RVEs @ {nx}×{ny} (px={px_um:.3f} µm, L={L_um:.1f} µm) "
            f"| target ⟨d_eq⟩≈{mean_d_um:.2f} µm, R≈{R_texture:.2f} "
            f"| Mg: D⊥={mg_params['D_perp_m2s']:.1e}, D∥={mg_params['D_par_m2s']:.1e}, "
            f"D_gb={mg_params['D_gb_m2s']:.1e}, t_gb={mg_params['gb_thickness_nm']} nm, "
            f"defects={mg_params['defect_frac']:.3f} (D_def={mg_params['D_defect_m2s']:.1e}), "
            f"GB conductance scaling={'on' if mg_params.get('conductance_scaling', False) else 'off'}",
            flush=True
        )

    rng = np.random.default_rng(seed)
    seeds = rng.integers(1, 10**12, size=pool_n)

    micro_pool = []
    Deffs = np.empty(pool_n, float)

    t0 = time.perf_counter()
    tick = max(1, pool_n // 10)

    for k, s in enumerate(seeds, start=1):
        Deff, C, D, sites, stats = micro_rve_D_eff(
            nx=nx, ny=ny, L_um=L_um,
            mean_d_um=mean_d_um, R_texture=R_texture,
            seed=int(s), **mg_params
        )
        micro_pool.append(dict(Deff=Deff, C=C, D=D, sites=sites, stats=stats, seed=int(s)))
        Deffs[k-1] = Deff

        if verbose >= 2:
            dmean = stats.get("grain_eqdiam_um_mean", np.nan)
            R = stats.get("orient_R", np.nan)
            gb_px = stats.get("gb_px", stats.get("gb_pixels", "?"))
            n_sites = stats.get("n_sites", len(sites) if hasattr(sites, "__len__") else "?")
            print(
                f"  - RVE {k:>3}/{pool_n}: D_eff={Deff:8.1f} µm²/s  "
                f"d̄={dmean:4.1f} µm  R={R:4.2f}  gb_px={gb_px}  sites={n_sites}  seed={int(s)}",
                flush=True
            )
        elif verbose >= 1 and (k % tick == 0 or k == pool_n):
            print(f"  - built {k}/{pool_n}", flush=True)

    t1 = time.perf_counter()

    # ---- summary stats ----
    if verbose >= 1:
        p10, p50, p90 = np.percentile(Deffs, [10, 50, 90])
        d_means = np.array([mp["stats"].get("grain_eqdiam_um_mean", np.nan) for mp in micro_pool], float)
        Rvals  = np.array([mp["stats"].get("orient_R", np.nan) for mp in micro_pool], float)

        def _nanmeanstd(x):
            return np.nanmean(x), np.nanstd(x)

        d_mu, d_sd = _nanmeanstd(d_means)
        R_mu, R_sd = _nanmeanstd(Rvals)

        print(
            "[micro-pool] summary:\n"
            f"  D_eff:  median={p50:,.1f} µm²/s  (p10={p10:,.1f}, p90={p90:,.1f})\n"
            f"  grains: ⟨d_eq⟩={d_mu:.2f} ± {d_sd:.2f} µm   (target {mean_d_um:.2f})\n"
            f"  texture R: {R_mu:.3f} ± {R_sd:.3f}   (target {R_texture:.3f})\n"
            f"  build time: {t1 - t0:.2f} s",
            flush=True
        )

    info = dict(
        nx=nx, ny=ny, L_um=L_um, px_um=px_um,
        mean_d_um=mean_d_um, R_texture=R_texture, **mg_params
    )
    return Deffs, micro_pool, info

# -------------------------- macro peridynamic ------------------------------- #

def neighbor_offsets(m):
    return [(di,dj) for di in range(-m,m+1) for dj in range(-m,m+1) if not (di==0 and dj==0)]

def peridynamic_corrosion(
    nx=88, ny=88, dx_um=3.0, R_um=80.0,
    m=3, timesteps=2000, cfl=0.5,
    C_thresh=0.2, C_far=0.0, C_solid_init=1.0,
    D_liq_m2s=1.5e-9,
    Deff_pool=None,
    tile_um=12.0,
    cap_solid_at_liquid=True,
    skip_solid_solid=True,
    record_every=20, record_max=400,
    verbose=1
):
    """
    Minimal peridynamic-like diffusion with dissolution:
    - Phase 0=solid, 1=liquid. Solid cells have D_map from micro; liquid has D_liq.
    - When C < C_thresh → cell liquefies (phase=1, D becomes liquid).
    """
    delta_um = m * dx_um
    K = 6.0/(np.pi * (delta_um**3))    # µm^-3
    dV = dx_um**2
    D_liq = D_liq_m2s * 1e12           # µm²/s

    # geometry & IC
    phase = np.zeros((nx,ny), dtype=int)
    solid = disk_mask(nx, ny, dx_um, R_um=R_um)
    phase[~solid] = 1
    C = np.full((nx,ny), C_far, float); C[solid] = C_solid_init

    # D_map tiling from pool + remember pool index per macro cell
    if Deff_pool is None or len(Deff_pool)==0:
        raise ValueError("Deff_pool must contain at least one value (µm²/s).")
    D_map = np.full((nx,ny), D_liq, float)
    pool = np.array(Deff_pool, float)
    if cap_solid_at_liquid:
        pool = np.minimum(pool, D_liq)

    tile_idx = np.full((nx,ny), -1, dtype=int)  # <--- NEW
    patch_cells = max(1, int(round(tile_um/dx_um)))
    k = 0
    for I in range(0, nx, patch_cells):
        i1 = min(I+patch_cells, nx)
        for J in range(0, ny, patch_cells):
            j1 = min(J+patch_cells, ny)
            blk = solid[I:i1, J:j1]
            if not np.any(blk):
                continue
            pick = k % len(pool)
            Dval = float(pool[pick])
            D_map[I:i1, J:j1][blk] = Dval
            tile_idx[I:i1, J:j1][blk] = pick  # <--- remember which pool entry this patch used
            k += 1

    # time step from worst-case spectral bound
    offs = neighbor_offsets(m)
    r_cache = {(di,dj): np.hypot(di*dx_um, dj*dx_um) for di,dj in offs}
    D_cap = max(D_liq, float(D_map.max()))
    lam_max = sum((1.0/r)*D_cap*K*dV for r in r_cache.values() if 0 < r <= delta_um)
    dt = cfl/lam_max if lam_max > 0 else 1.0
    if verbose:
        print(f"[peridynamic] δ={delta_um:.1f} µm  K={K:.3e}  ΔV={dV:.1f}  dt={dt:.3e} s")

    # snapshots for GIF
    snaps_t = []; snaps_C = []; snaps_P = []
    def rec(t):
        if record_every>0 and len(snaps_t)<record_max:
            snaps_t.append(t); snaps_C.append(C.copy()); snaps_P.append(phase.copy())
    rec(0.0)

    # stepping
    t = 0.0
    tick = max(1, timesteps//10)
    for step in range(1, timesteps+1):
        Cn = C.copy()
        for i in range(nx):
            for j in range(ny):
                # simple Dirichlet collar on outermost m cells
                if (i<m) or (i>=nx-m) or (j<m) or (j>=ny-m):
                    Cn[i,j] = C_far
                    continue
                acc = 0.0; Di = D_map[i,j]
                for di,dj in offs:
                    ii, jj = i+di, j+dj
                    if 0<=ii<nx and 0<=jj<ny:
                        r = r_cache[(di,dj)]
                        if 0 < r <= delta_um:
                            if skip_solid_solid and (phase[i,j]==0 and phase[ii,jj]==0):
                                continue
                            Dj = D_map[ii,jj]
                            acc += (0.5*(Di+Dj)) * ((C[ii,jj]-C[i,j])/r) * dV
                Cn[i,j] = C[i,j] + dt*(K*acc)
        C = Cn

        # dissolution rule
        newly_liq = (phase==0) & (C < C_thresh)
        if np.any(newly_liq):
            phase[newly_liq] = 1
            D_map[newly_liq] = D_liq

        t += dt
        if (step % record_every)==0:
            rec(t)
        if verbose and (step%tick==0 or step==timesteps):
            print(f"  - step {step}/{timesteps}")

    meta = dict(dt=dt, T_final=t, delta_um=delta_um, D_liq=D_liq, tile_idx=tile_idx)  # <--- include tile_idx
    return C, D_map, phase, dict(t=np.array(snaps_t), C=snaps_C, phase=snaps_P), meta

# ------------------------------ plotting ----------------------------------- #

def plot_macro(D_map, C, phase):
    fig, ax = plt.subplots(1,3, figsize=(13,4), constrained_layout=True)
    im0 = ax[0].imshow(D_map.T, origin="lower", cmap="viridis"); plt.colorbar(im0, ax=ax[0], label="D_eff [µm²/s]"); ax[0].set_title("Macro D_eff")
    im1 = ax[1].imshow(C.T, origin="lower", cmap="viridis", vmin=0, vmax=1); plt.colorbar(im1, ax=ax[1], label="C"); ax[1].set_title("Macro C")
    im2 = ax[2].imshow(phase.T, origin="lower", cmap="cividis", vmin=0, vmax=1); plt.colorbar(im2, ax=ax[2], label="Phase"); ax[2].set_title("Phase (0=solid,1=liq)")
    plt.show()

def animate_macro(snaps, save_combined="corrosion_combined.gif", dpi=120, interval_ms=120):
    t = snaps["t"]; C_list = snaps["C"]; P_list = snaps["phase"]
    fig, axs = plt.subplots(1,2, figsize=(9,4), constrained_layout=True)
    imC = axs[0].imshow(C_list[0].T, origin="lower", cmap="viridis", vmin=0, vmax=1); axs[0].set_title("C")
    imP = axs[1].imshow(P_list[0].T, origin="lower", cmap="cividis", vmin=0, vmax=1); axs[1].set_title("Phase")
    plt.colorbar(imC, ax=axs[0]); plt.colorbar(imP, ax=axs[1])
    supt = fig.suptitle(f"t = {t[0]:.3f} s")

    def upd(k):
        imC.set_data(C_list[k].T)
        imP.set_data(P_list[k].T)
        supt.set_text(f"t = {t[k]:.3f} s")
        return imC, imP, supt

    ani = animation.FuncAnimation(fig, upd, frames=len(t), interval=interval_ms, blit=False, repeat=True)
    if save_combined:
        fps = max(1, int(round(1000.0/interval_ms)))
        ani.save(save_combined, writer=animation.PillowWriter(fps=fps), dpi=dpi)
        print(f"[anim] saved {save_combined}  ({len(t)} frames @ {fps} fps)")
    plt.close(fig)

def plot_voronoi_generators(pts, title="Voronoi generators (sites)"):
    """Quick Voronoi preview of sites (grains)."""
    try:
        from scipy.spatial import Voronoi, voronoi_plot_2d
        import matplotlib.pyplot as plt
        fig, ax = plt.subplots(figsize=(4,4))
        vor = Voronoi(pts)
        voronoi_plot_2d(vor, ax=ax, show_vertices=False, line_colors="k",
                        line_width=0.8, line_alpha=0.8, point_size=8)
        ax.set_aspect("equal"); ax.set_title(title)
        plt.show()
    except Exception:
        # fallback: just scatter the seeds in [0,1]^2
        fig, ax = plt.subplots(figsize=(4,4))
        ax.scatter(pts[:,0], pts[:,1], s=10, c="k")
        ax.set_xlim(0,1); ax.set_ylim(0,1); ax.set_aspect("equal")
        ax.set_title(title); plt.show()

def plot_field(Z, title, label, transpose=True):
    import matplotlib.pyplot as plt
    fig, ax = plt.subplots(figsize=(5,4))
    data = Z.T if transpose else Z
    im = ax.imshow(data, origin="lower", cmap="viridis")
    fig.colorbar(im, ax=ax, label=label); ax.set_title(title); plt.show()

def plot_initial_macro_mask(nx, ny, dx_um, R_um, m, sample_cell=None,
                            title="Initial macro domain (solid disk + liquid collar)"):
    solid = disk_mask(nx, ny, dx_um, R_um=R_um)
    collar = np.zeros((nx,ny), dtype=bool)
    collar[:m,:]=True; collar[-m:,:]=True; collar[:, :m]=True; collar[:, -m:]=True

    fig, ax = plt.subplots(1,2, figsize=(10,4), constrained_layout=True)
    im0 = ax[0].imshow(solid.T, origin="lower", cmap="cividis")
    ax[0].set_title(title); fig.colorbar(im0, ax=ax[0], label="Solid=1 / Liquid=0")
    im1 = ax[1].imshow(collar.T, origin="lower", cmap="Greys")
    ax[1].set_title(f"Dirichlet collar (m={m})")
    if sample_cell is not None:
        i,j = sample_cell
        for a in ax:
            a.add_patch(plt.Rectangle((j-0.5, i-0.5), 1, 1, fill=False, lw=2))
    plt.show()

def preview_macro_and_one_micro(
    nx, ny, dx_um, R_um, m,
    D_map, meta, micro_pool, pick="edge", ij_override=None
):
    """
    - pick: 'edge'|'center'|'random' or pass ij_override=(i,j)
    - requires meta['tile_idx'] from peridynamic_corrosion and 'micro_pool' from build_micro_pool
    """
    # choose a solid macro cell (prefer an edge/ring cell)
    solid = disk_mask(nx, ny, dx_um, R_um=R_um)
    cand = np.argwhere(solid)
    if ij_override is not None:
        i0,j0 = ij_override
    elif pick == "center":
        i0,j0 = nx//2, ny//2
        if not solid[i0,j0]:
            i0,j0 = cand[len(cand)//2]
    elif pick == "random":
        i0,j0 = cand[np.random.default_rng(7).integers(0, len(cand))]
    else:  # edge ring
        eroded = binary_dilate(solid, -1) if False else (solid[1:-1,1:-1] if nx>2 and ny>2 else solid)
        ring = solid ^ np.pad(eroded, 1, constant_values=False) if (nx>2 and ny>2) else solid
        ring_idx = np.argwhere(ring)
        if len(ring_idx)==0:
            i0,j0 = cand[len(cand)//3]
        else:
            i0,j0 = ring_idx[len(ring_idx)//2]

    # plot macro mask with highlight
    plot_initial_macro_mask(nx, ny, dx_um, R_um, m, sample_cell=(i0,j0))

    # find which pool entry this macro cell used
    tile_idx = meta.get("tile_idx", None)
    if tile_idx is None:
        raise RuntimeError("meta['tile_idx'] was not set. Update peridynamic_corrosion as shown.")
    k = int(tile_idx[i0, j0])
    if k < 0:
        raise RuntimeError("Selected cell is not a solid tile (or tile index missing).")

    entry = micro_pool[k % len(micro_pool)]
    Deff = entry["Deff"]; C = entry["C"]; D = entry["D"]; pts = entry["sites"]; stats = entry["stats"]

    print(f"[preview] macro cell=({i0},{j0}) uses pool[{k % len(micro_pool)}]  "
          f"D_eff={Deff:.2f} µm²/s  (L={stats['L_um']} µm, px={stats['px_um']:.3f} µm, "
          f"sites={stats['n_sites']}, gb_px={stats['gb_px']})")

    plot_voronoi_generators(pts, title=f"Voronoi (pool idx {k % len(micro_pool)})")
    plot_field(D, "Micro diffusivity map", "D [µm²/s]", transpose=True)
    plot_field(C, "Micro concentration", "C [-]", transpose=True)

# -------------------------------- main ------------------------------------- #

if __name__ == "__main__":
    np.set_printoptions(precision=3, suppress=True)

    # ---- Mg micro defaults (same spirit/values as your current model) ----
    mean_d_um  = 5.5
    R_texture  = 0.90
    L_um_micro = 24.0
    px_target_um = 0.75
    micro_pool_n = 8

    mg_params = dict(
        D_perp_m2s=1e-12, D_par_m2s=1e-11,
        D_gb_m2s=1e-10, gb_thickness_nm=2.0,
        defect_frac=0.003, D_defect_m2s=1e-9,
        conductance_scaling=True
    )

    print("[micro] building pool...")
    # --- micro pool with full fields ---
    Deff_pool, micro_pool, micro_info = build_micro_pool(
        pool_n=micro_pool_n,
        L_um=L_um_micro, px_target_um=px_target_um,
        mean_d_um=mean_d_um, R_texture=R_texture,
        mg_params=mg_params, seed=123
    )
    print(f"[micro] pool D_eff stats (µm²/s): median={np.median(Deff_pool):.1f}, "
          f"p10={np.percentile(Deff_pool,10):.1f}, p90={np.percentile(Deff_pool,90):.1f}")

    # ---- Macro (80 µm disk on 88×88 at 3 µm, δ = 9 µm) ----
    nx=ny=88; dx_um=3.0; R_um=80.0; m=3
    tile_um = 3.0      # 4×4 macro cells share same D_eff (easy to see; set 6.0 for finer)
    timesteps = 1000
    record_every = 20

    # --- macro solve (unchanged call signature if you applied the peridynamic edit) ---
    C, D_map, phase, snaps, meta = peridynamic_corrosion(
        nx=nx, ny=ny, dx_um=dx_um, R_um=R_um,
        m=m, timesteps=timesteps, cfl=0.5,
        C_thresh=0.2, C_far=0.0, C_solid_init=1.0,
        D_liq_m2s=1.5e-9,
        Deff_pool=Deff_pool, tile_um=12.0,
        cap_solid_at_liquid=True,
        skip_solid_solid=True,
        record_every=record_every, record_max=400,
        verbose=1
    )
    print(f"[meta] dt={meta['dt']:.3e} s,  T_final={meta['T_final']:.3e} s,  δ={meta['delta_um']:.1f} µm")

    # --- normal plots/GIF ---
    plot_macro(D_map, C, phase)
    animate_macro(snaps, save_combined="corrosion_combined.gif", dpi=120, interval_ms=120)

    # --- NEW: preview one macro cell's microstructure (edge cell by default) ---
    preview_macro_and_one_micro(
        nx, ny, dx_um, R_um, m,
        D_map, meta, micro_pool,
        pick="edge"      # 'edge'|'center'|'random' or ij_override=(i,j)
    )